<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roman Ridge Luxury City 3D</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
      background: #000;
    }
    
    #canvas-container {
      width: 100vw;
      height: 100vh;
    }
    
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      color: #daa520;
      padding: 50px 70px;
      border-radius: 20px;
      font-size: 28px;
      font-weight: bold;
      border: 3px solid #b8860b;
      text-align: center;
      z-index: 1000;
      box-shadow: 0 20px 60px rgba(0,0,0,0.9);
    }
    
    #loading.hidden {
      display: none;
    }
    
    #progress {
      font-size: 56px;
      color: #fff;
      margin: 20px 0;
    }
    
    #progress-text {
      font-size: 16px;
      color: #999;
      margin-top: 15px;
    }
    
    #controls {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.95);
      color: #daa520;
      padding: 30px;
      border-radius: 15px;
      max-width: 350px;
      border: 2px solid #b8860b;
      box-shadow: 0 10px 40px rgba(0,0,0,0.8);
      z-index: 100;
    }
    
    #controls h2 {
      margin: 0 0 20px 0;
      color: #daa520;
      font-size: 24px;
      border-bottom: 2px solid #b8860b;
      padding-bottom: 12px;
    }
    
    .button-group {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    button {
      background: #444;
      color: #fff;
      border: 2px solid #666;
      padding: 14px 22px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      font-size: 15px;
      flex: 1;
      transition: all 0.3s ease;
      min-width: 140px;
    }
    
    button:hover {
      background: #555;
      transform: translateY(-2px);
    }
    
    button.active {
      background: linear-gradient(135deg, #daa520 0%, #b8860b 100%);
      border: 2px solid #ffd700;
      box-shadow: 0 5px 20px rgba(218, 165, 32, 0.5);
    }
    
    .walk-controls {
      font-size: 14px;
      line-height: 2;
      color: #ddd;
      background: rgba(218, 165, 32, 0.1);
      padding: 18px;
      border-radius: 10px;
      margin-bottom: 18px;
    }
    
    .walk-controls strong {
      color: #daa520;
      display: block;
      margin-bottom: 8px;
    }
    
    .walk-controls span {
      color: #ffd700;
      font-weight: bold;
    }
    
    .features {
      font-size: 13px;
      color: #aaa;
      line-height: 1.9;
    }
    
    .features strong {
      color: #daa520;
      display: block;
      margin-bottom: 10px;
    }
    
    .footer-info {
      margin-top: 18px;
      padding-top: 18px;
      border-top: 1px solid #555;
      font-size: 11px;
      color: #888;
      text-align: center;
    }
    
    .footer-info span {
      color: #daa520;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="loading">
    <div>Loading Your Luxury City...</div>
    <div id="progress">0%</div>
    <div id="progress-text">Loading building designs from Roman Ridge</div>
  </div>
  
  <div id="controls">
    <h2>üèôÔ∏è Roman Ridge Luxury City</h2>
    
    <div class="button-group">
      <button id="walkBtn">üö∂ Walk Mode OFF</button>
      <button id="rotateBtn" class="active">üîÑ 360¬∞ ON</button>
    </div>
    
    <div id="walkControls" class="walk-controls" style="display: none;">
      <strong>üéÆ Walk Controls:</strong>
      <span>W</span> - Move Forward<br>
      <span>S</span> - Move Backward<br>
      <span>A</span> - Turn Left<br>
      <span>D</span> - Turn Right<br>
      <span>Q</span> - Fly Up<br>
      <span>E</span> - Fly Down
    </div>
    
    <div class="features">
      <strong>‚ú® City Features:</strong>
      ‚Ä¢ 12 Luxury Skyscrapers (Your Designs)<br>
      ‚Ä¢ Shopping Mall & Hospital<br>
      ‚Ä¢ Schools, Church & Mosque<br>
      ‚Ä¢ Flowing Photorealistic River<br>
      ‚Ä¢ 40+ Luxury Vehicles<br>
      ‚Ä¢ 80+ Residents<br>
      ‚Ä¢ 150+ Trees & Gardens<br>
      ‚Ä¢ Real-time Lighting & Shadows
    </div>
    
    <div class="footer-info">
      Powered by <span>Scribe Haus</span><br>
      Using 29 Original Designs
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Building images - your actual designs
    const buildingImages = [
      'a1.jpg', 'a2.jpg', 'a3.jpg', 'a.jpg', 'b.jpg', 'c.jpg', 'd.jpg', 
      'e.jpg', 'f.jpg', 'g.jpg', 'h.jpg', 'i.jpg', 'j.jpg', 'k.jpg', 
      'l.jpg', 'm.jpg', 'n.jpg', 'o.jpg', 'p.jpg', 'q.jpg', 'r.jpg', 
      's.jpg', 't.jpg', 'u.jpg', 'v.jpg', 'w.jpg', 'x.jpg', 'y.jpg', '1.png'
    ];

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 200, 1200);

    // Camera
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      3000
    );
    camera.position.set(0, 120, 350);
    camera.lookAt(0, 50, 0);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowShadowMap;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfff5e1, 1.5);
    sunLight.position.set(200, 300, 100);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 4096;
    sunLight.shadow.mapSize.height = 4096;
    sunLight.shadow.camera.far = 800;
    sunLight.shadow.camera.left = -400;
    sunLight.shadow.camera.right = 400;
    sunLight.shadow.camera.top = 400;
    sunLight.shadow.camera.bottom = -400;
    scene.add(sunLight);

    const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x2d5016, 0.6);
    scene.add(hemiLight);

    // Ground
    const groundGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
    const vertices = groundGeometry.attributes.position.array;
    for (let i = 0; i < vertices.length; i += 3) {
      vertices[i + 2] = Math.random() * 0.8;
    }
    groundGeometry.attributes.position.needsUpdate = true;
    groundGeometry.computeVertexNormals();

    const groundMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a5a1a,
      roughness: 0.9,
      metalness: 0.1
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Roads
    const roadMaterial = new THREE.MeshStandardMaterial({
      color: 0x2a2a2a,
      roughness: 0.7,
      metalness: 0.3
    });

    for (let i = -5; i <= 5; i++) {
      const road = new THREE.Mesh(new THREE.PlaneGeometry(2000, 15), roadMaterial);
      road.rotation.x = -Math.PI / 2;
      road.position.set(0, 0.2, i * 120);
      road.receiveShadow = true;
      scene.add(road);

      const road2 = new THREE.Mesh(new THREE.PlaneGeometry(15, 2000), roadMaterial);
      road2.rotation.x = -Math.PI / 2;
      road2.position.set(i * 120, 0.2, 0);
      road2.receiveShadow = true;
      scene.add(road2);
    }

    // River
    const riverGeometry = new THREE.PlaneGeometry(800, 40, 200, 50);
    const riverMaterial = new THREE.MeshStandardMaterial({
      color: 0x0077be,
      transparent: true,
      opacity: 0.85,
      roughness: 0.05,
      metalness: 0.9
    });
    const river = new THREE.Mesh(riverGeometry, riverMaterial);
    river.rotation.x = -Math.PI / 2;
    river.rotation.z = Math.PI / 8;
    river.position.set(-100, 0.3, 0);
    scene.add(river);

    let riverTime = 0;

    // Texture loader
    const textureLoader = new THREE.TextureLoader();
    const loadedTextures = {};
    let loadedCount = 0;

    // Load textures
    function loadTexture(imageName) {
      return new Promise((resolve) => {
        textureLoader.load(
          imageName,
          (texture) => {
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            loadedTextures[imageName] = texture;
            loadedCount++;
            const progress = Math.floor((loadedCount / buildingImages.length) * 100);
            document.getElementById('progress').textContent = progress + '%';
            resolve(texture);
          },
          undefined,
          (error) => {
            console.warn('Failed to load ' + imageName, error);
            loadedCount++;
            const progress = Math.floor((loadedCount / buildingImages.length) * 100);
            document.getElementById('progress').textContent = progress + '%';
            resolve(null);
          }
        );
      });
    }

    // Create photorealistic building
    function createBuilding(x, z, height, textureKey) {
      const group = new THREE.Group();
      const width = 40;
      const depth = 40;

      const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
      const texture = loadedTextures[textureKey];
      
      let materials;
      if (texture) {
        const faceMaterial = new THREE.MeshStandardMaterial({
          map: texture,
          roughness: 0.3,
          metalness: 0.6
        });

        materials = [
          faceMaterial.clone(),
          faceMaterial.clone(),
          new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4, metalness: 0.5 }),
          new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.6, metalness: 0.4 }),
          faceMaterial.clone(),
          faceMaterial.clone()
        ];
      } else {
        const fallbackMaterial = new THREE.MeshStandardMaterial({
          color: 0xb8860b,
          roughness: 0.3,
          metalness: 0.7
        });
        materials = Array(6).fill(fallbackMaterial);
      }

      const building = new THREE.Mesh(buildingGeometry, materials);
      building.position.y = height / 2;
      building.castShadow = true;
      building.receiveShadow = true;
      group.add(building);

      // Windows
      for (let floor = 0; floor < height / 4; floor++) {
        for (let side = 0; side < 4; side++) {
          const windowRowGeometry = new THREE.PlaneGeometry(width * 0.9, 2);
          const windowMaterial = new THREE.MeshStandardMaterial({
            color: 0x88ccff,
            emissive: 0xffaa00,
            emissiveIntensity: 0.3,
            roughness: 0,
            metalness: 1,
            transparent: true,
            opacity: 0.8
          });
          
          const windowRow = new THREE.Mesh(windowRowGeometry, windowMaterial);
          const y = floor * 4 + 3;
          
          switch(side) {
            case 0:
              windowRow.position.set(0, y, depth/2 + 0.1);
              break;
            case 1:
              windowRow.position.set(0, y, -depth/2 - 0.1);
              windowRow.rotation.y = Math.PI;
              break;
            case 2:
              windowRow.position.set(width/2 + 0.1, y, 0);
              windowRow.rotation.y = Math.PI / 2;
              break;
            case 3:
              windowRow.position.set(-width/2 - 0.1, y, 0);
              windowRow.rotation.y = -Math.PI / 2;
              break;
          }
          
          group.add(windowRow);
        }
      }

      // Rooftop
      const roofGeometry = new THREE.BoxGeometry(width + 2, 4, depth + 2);
      const roofMaterial = new THREE.MeshStandardMaterial({
        color: 0xdaa520,
        roughness: 0.2,
        metalness: 0.8,
        emissive: 0xb8860b,
        emissiveIntensity: 0.2
      });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.y = height + 2;
      roof.castShadow = true;
      group.add(roof);

      group.position.set(x, 0, z);
      return group;
    }

    // Create amenity building
    function createAmenity(x, z, type, textureKey) {
      const group = new THREE.Group();
      const height = 30;
      const size = 50;

      const texture = loadedTextures[textureKey];
      const buildingGeometry = new THREE.BoxGeometry(size, height, size);
      
      let materials;
      if (texture) {
        const mat = new THREE.MeshStandardMaterial({
          map: texture,
          roughness: 0.4,
          metalness: 0.5
        });
        materials = [
          mat.clone(), mat.clone(),
          new THREE.MeshStandardMaterial({ color: 0x444444 }),
          new THREE.MeshStandardMaterial({ color: 0x333333 }),
          mat.clone(), mat.clone()
        ];
      } else {
        const colors = {
          mall: 0xdaa520,
          hospital: 0xff4444,
          school: 0x4169e1,
          church: 0xf5f5dc,
          mosque: 0x90ee90
        };
        const mat = new THREE.MeshStandardMaterial({
          color: colors[type] || 0xcccccc,
          roughness: 0.5,
          metalness: 0.4
        });
        materials = mat;
      }

      const building = new THREE.Mesh(buildingGeometry, materials);
      building.position.y = height / 2;
      building.castShadow = true;
      building.receiveShadow = true;
      group.add(building);

      if (type === 'church' || type === 'mosque') {
        const domeGeometry = new THREE.SphereGeometry(10, 32, 32);
        const domeMaterial = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          roughness: 0.1,
          metalness: 0.9
        });
        const dome = new THREE.Mesh(domeGeometry, domeMaterial);
        dome.position.y = height + 8;
        dome.castShadow = true;
        group.add(dome);

        if (type === 'mosque') {
          const spireGeometry = new THREE.CylinderGeometry(1, 1, 20, 8);
          const spire = new THREE.Mesh(spireGeometry, domeMaterial);
          spire.position.set(size/2 - 5, height + 10, size/2 - 5);
          group.add(spire);
        }
      }

      group.position.set(x, 0, z);
      return group;
    }

    // Create luxury car
    function createCar(x, z, color) {
      const carGroup = new THREE.Group();
      
      const bodyGeometry = new THREE.BoxGeometry(5, 1.8, 2.5);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.1,
        metalness: 0.95
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 1.5;
      body.castShadow = true;
      carGroup.add(body);

      const cabinGeometry = new THREE.BoxGeometry(3, 1.2, 2.3);
      const glassMaterial = new THREE.MeshStandardMaterial({
        color: 0x111111,
        roughness: 0.05,
        metalness: 0.9,
        transparent: true,
        opacity: 0.7
      });
      const cabin = new THREE.Mesh(cabinGeometry, glassMaterial);
      cabin.position.set(-0.3, 2.7, 0);
      carGroup.add(cabin);

      const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
      const wheelMaterial = new THREE.MeshStandardMaterial({
        color: 0x0a0a0a,
        roughness: 0.6,
        metalness: 0.8
      });
      
      [[1.5, 0.5, 1.2], [1.5, 0.5, -1.2], [-1.5, 0.5, 1.2], [-1.5, 0.5, -1.2]].forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(pos[0], pos[1], pos[2]);
        wheel.castShadow = true;
        carGroup.add(wheel);
      });

      carGroup.position.set(x, 0, z);
      carGroup.rotation.y = Math.random() * Math.PI * 2;
      return carGroup;
    }

    // Create person
    function createPerson(x, z) {
      const group = new THREE.Group();
      
      const bodyGeo = new THREE.CylinderGeometry(0.35, 0.4, 1.8, 12);
      const colors = [0x2c3e50, 0x8e44ad, 0x27ae60, 0xe74c3c, 0x3498db];
      const bodyMat = new THREE.MeshStandardMaterial({
        color: colors[Math.floor(Math.random() * colors.length)],
        roughness: 0.8
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 1.8;
      body.castShadow = true;
      group.add(body);

      const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
      const headMat = new THREE.MeshStandardMaterial({
        color: 0xffdbac,
        roughness: 0.7
      });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 3;
      head.castShadow = true;
      group.add(head);

      group.position.set(x, 0, z);
      return group;
    }

    // Create tree
    function createTree(x, z) {
      const group = new THREE.Group();
      
      const trunkGeo = new THREE.CylinderGeometry(0.6, 0.8, 6, 10);
      const trunkMat = new THREE.MeshStandardMaterial({
        color: 0x4a3728,
        roughness: 0.9
      });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 3;
      trunk.castShadow = true;
      group.add(trunk);

      const leavesGeo = new THREE.SphereGeometry(4, 12, 12);
      const leavesMat = new THREE.MeshStandardMaterial({
        color: 0x1a5a1a,
        roughness: 0.9
      });
      const leaves = new THREE.Mesh(leavesGeo, leavesMat);
      leaves.position.y = 7;
      leaves.castShadow = true;
      group.add(leaves);

      group.position.set(x, 0, z);
      return group;
    }

    // Build city after loading textures
    Promise.all(buildingImages.map(img => loadTexture(img))).then(() => {
      // Skyscrapers
      const positions = [
        [-200, -180, 180], [-200, 0, 160], [-200, 180, 200],
        [-80, -180, 170], [-80, 0, 150], [-80, 180, 190],
        [80, -180, 185], [80, 0, 145], [80, 180, 175],
        [200, -180, 155], [200, 0, 195], [200, 180, 165]
      ];

      positions.forEach((pos, i) => {
        const texture = buildingImages[i % buildingImages.length];
        scene.add(createBuilding(pos[0], pos[1], pos[2], texture));
      });

      // Amenities
      scene.add(createAmenity(-140, 90, 'mall', buildingImages[12]));
      scene.add(createAmenity(-140, -90, 'hospital', buildingImages[13]));
      scene.add(createAmenity(140, 90, 'school', buildingImages[14]));
      scene.add(createAmenity(140, -90, 'church', buildingImages[15]));
      scene.add(createAmenity(0, -250, 'mosque', buildingImages[16]));

      // Cars
      const carColors = [0xdc143c, 0x000000, 0xffffff, 0x0033cc, 0xffd700, 0x8b0000];
      for (let i = 0; i < 40; i++) {
        const x = (Math.random() - 0.5) * 500;
        const z = (Math.random() - 0.5) * 500;
        if (Math.abs(x + 100) > 50 || Math.abs(z) > 30) {
          scene.add(createCar(x, z, carColors[Math.floor(Math.random() * carColors.length)]));
        }
      }

      // People
      for (let i = 0; i < 80; i++) {
        const x = (Math.random() - 0.5) * 500;
        const z = (Math.random() - 0.5) * 500;
        scene.add(createPerson(x, z));
      }

      // Trees
      for (let i = 0; i < 150; i++) {
        const x = (Math.random() - 0.5) * 700;
        const z = (Math.random() - 0.5) * 700;
        if (Math.abs(x + 100) > 60 || Math.abs(z) > 40) {
          scene.add(createTree(x, z));
        }
      }

      document.getElementById('loading').classList.add('hidden');
    });

    // Controls
    let walkMode = false;
    let autoRotate = true;
    let angle = 0;
    const keys = {};

    document.getElementById('walkBtn').addEventListener('click', () => {
      walkMode = !walkMode;
      autoRotate = false;
      document.getElementById('walkBtn').classList.toggle('active');
      document.getElementById('rotateBtn').classList.remove('active');
      document.getElementById('walkBtn').textContent = walkMode ? 'üö∂ Walk Mode ON' : 'üö∂ Walk Mode OFF';
      document.getElementById('walkControls').style.display = walkMode ? 'block' : 'none';
    });

    document.getElementById('rotateBtn').addEventListener('click', () => {
      autoRotate = !autoRotate;
      walkMode = false;
      document.getElementById('rotateBtn').classList.toggle('active');
      document.getElementById('walkBtn').classList.remove('active');
      document.getElementById('rotateBtn').textContent = autoRotate ? 'üîÑ 360¬∞ ON' : 'üîÑ 360¬∞ OFF';
      document.getElementById('walkBtn').textContent = 'üö∂ Walk Mode OFF';
      document.getElementById('walkControls').style.display = 'none';
    });

    window.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
    });

    window.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Animate river
      riverTime += 0.003;
      const riverPos = river.geometry.attributes.position;
      for (let i = 0; i < riverPos.count; i++) {
        const x = riverPos.getX(i);
        const y = riverPos.getY(i);
        riverPos.setZ(i, Math.sin(x * 0.03 + riverTime) * 1.5 + Math.cos(y * 0.02 + riverTime) * 1);
      }
      riverPos.needsUpdate = true;

      if (walkMode) {
        const speed = 3;
        const turnSpeed = 0.04;

        if (keys['w']) {
          camera.position.x += Math.sin(camera.rotation.y) * speed;
          camera.position.z += Math.cos(camera.rotation.y) * speed;
        }
        if (keys['s']) {
          camera.position.x -= Math.sin(camera.rotation.y) * speed;
          camera.position.z -= Math.cos(camera.rotation.y) * speed;
        }
        if (keys['a']) camera.rotation.y += turnSpeed;
        if (keys['d']) camera.rotation.y -= turnSpeed;
        if (keys['q']) camera.position.y += 2;
        if (keys['e']) camera.position.y -= 2;

        camera.position.y = Math.max(5, Math.min(camera.position.y, 300));
      } else if (autoRotate) {
        angle += 0.002;
        camera.position.x = Math.sin(angle) * 350;
        camera.position.z = Math.cos(angle) * 350;
        camera.position.y = 120 + Math.sin(angle * 0.5) * 30;
        camera.lookAt(0, 60, 0);
      }

      renderer.render(scene, camera);
    }

    animate();

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

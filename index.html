import * as THREE from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';

// SkyscraperScene(container) // High-detail, photoreal-focused three.js scene for a client-ready upscale model. // Features: PBR MeshPhysicalMaterials, layered glass (transmission), fine mullions, terraces, planters, HDR-like environment via PMREM-like sky, contact shadow plane, high-res shadows, and GLB export.

export default function SkyscraperScene(container) { // --- Renderer / scene --- const scene = new THREE.Scene(); scene.background = new THREE.Color(0xcfeef6);

const camera = new THREE.PerspectiveCamera(42, container.clientWidth / container.clientHeight, 0.1, 5000); camera.position.set(220, 180, 340);

const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true }); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.setSize(container.clientWidth, container.clientHeight); renderer.outputEncoding = THREE.sRGBEncoding; renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; container.appendChild(renderer.domElement);

// --- Controls --- const controls = new OrbitControls(camera, renderer.domElement); controls.target.set(0, 60, 0); controls.enableDamping = true; controls.dampingFactor = 0.06;

// --- Lighting: golden-hour cinematic --- const hemi = new THREE.HemisphereLight(0xfff7ee, 0x445566, 0.55); scene.add(hemi);

const sun = new THREE.DirectionalLight(0xfff1d6, 1.2); sun.position.set(300, 360, 120); sun.castShadow = true; sun.shadow.camera.near = 0.5; sun.shadow.camera.far = 1200; sun.shadow.camera.left = -600; sun.shadow.camera.right = 600; sun.shadow.camera.top = 600; sun.shadow.camera.bottom = -600; sun.shadow.mapSize.set(4096, 4096); scene.add(sun);

const fill = new THREE.DirectionalLight(0xb9e8ff, 0.22); fill.position.set(-200, 80, -140); scene.add(fill);

// subtle artificial rim light const rim = new THREE.DirectionalLight(0xffe6d0, 0.08); rim.position.set(-300, 120, 300); scene.add(rim);

// --- Ground / contact shadow --- const groundMat = new THREE.MeshPhysicalMaterial({ color: 0xe9e6df, roughness: 0.95, metalness: 0 }); const ground = new THREE.Mesh(new THREE.PlaneGeometry(1500, 1500), groundMat); ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; scene.add(ground);

// contact shadow: a subtle dark circle under building (not real AO but presentational) const contactGeo = new THREE.PlaneGeometry(420, 420); const contactTex = new THREE.Texture(generateRadialShadowCanvas(1024)); contactTex.needsUpdate = true; contactTex.encoding = THREE.sRGBEncoding; const contactMat = new THREE.MeshBasicMaterial({ map: contactTex, transparent: true, opacity: 0.55 }); const contactMesh = new THREE.Mesh(contactGeo, contactMat); contactMesh.rotation.x = -Math.PI / 2; contactMesh.position.y = 0.02; scene.add(contactMesh);

// --- Materials: PBR physical look --- const glassThin = new THREE.MeshPhysicalMaterial({ color: 0xe9f8ff, metalness: 0.0, roughness: 0.05, transmission: 0.85, transparent: true, opacity: 0.98, clearcoat: 0.18, clearcoatRoughness: 0.02, });

const aluminum = new THREE.MeshPhysicalMaterial({ color: 0xc7cbd0, metalness: 0.95, roughness: 0.22, clearcoat: 0.06 }); const bronze = new THREE.MeshPhysicalMaterial({ color: 0xb86b3a, metalness: 0.35, roughness: 0.55 }); const stone = new THREE.MeshPhysicalMaterial({ color: 0xd6d0c6, roughness: 0.9 }); const planterMat = new THREE.MeshPhysicalMaterial({ color: 0x2f6f38, roughness: 0.9 });

// Root group for building + context const root = new THREE.Group(); scene.add(root);

// --- Surrounding context (low-rise Accra-inspired) --- const contextGrp = new THREE.Group(); for (let i = 0; i < 9; i++) { const w = 18 + Math.random() * 28; const d = 12 + Math.random() * 20; const h = 12 + Math.random() * 28; const x = (i % 3 - 1) * 140 + (Math.random() * 20 - 10); const z = Math.floor(i / 3) * -120 + (Math.random() * 20 - 10) - 60; const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), stone); b.position.set(x, h / 2, z); b.castShadow = true; b.receiveShadow = true; contextGrp.add(b); } root.add(contextGrp);

// --- High-detail skyscraper builder --- const building = new THREE.Group(); root.add(building);

const params = { floors: 23, baseW: 46, baseD: 34, floorH: 3.6, taper: 0.20, rotationOffset: -6, };

function buildHighDetail() { // clear previous while (building.children.length) { const c = building.children[0]; c.traverse(n => { if (n.geometry) n.geometry.dispose(); if (n.material) { if (Array.isArray(n.material)) n.material.forEach(m=>m.dispose()); else n.material.dispose(); } }); building.remove(c); }

// podium with stepped plinths
const plinth = new THREE.Group();
const plinthHeights = [2.5, 2.2, 1.8];
let zOff = 0;
for (let i = 0; i < plinthHeights.length; i++) {
  const s = 1 + i * 0.08;
  const geo = new THREE.BoxGeometry(params.baseW * (1.4 - i * 0.06) * s, plinthHeights[i], params.baseD * (1.6 - i * 0.06) * s);
  const m = new THREE.Mesh(geo, stone);
  m.position.y = zOff + plinthHeights[i] / 2;
  zOff += plinthHeights[i];
  m.castShadow = true; m.receiveShadow = true;
  plinth.add(m);
}
building.add(plinth);

// vertical core (slightly offset for composition)
const core = new THREE.Mesh(new THREE.BoxGeometry(10, params.floors * params.floorH * 0.98, 10), bronze);
core.position.set(-params.baseW * 0.18, zOff + (params.floors * params.floorH * 0.98) / 2, 0);
core.castShadow = true; building.add(core);

// stacked articulated floor slabs with mullioned glazing and balconies
let y = zOff;
for (let i = 0; i < params.floors; i++) {
  const t = i / params.floors;
  const w = params.baseW * (1 - params.taper * t) + Math.sin(i * 0.6) * 0.9;
  const d = params.baseD * (1 - params.taper * t * 0.6) + Math.cos(i * 0.45) * 0.7;
  const h = params.floorH * (1 + (i % 4 === 0 ? 0.18 : 0));

  // main slab (thin floor plate)
  const slabGeom = new THREE.BoxGeometry(w, 0.28, d);
  const slab = new THREE.Mesh(slabGeom, stone);
  slab.position.set(Math.sin(i * 0.12) * 0.8, y + 0.14, Math.cos(i * 0.08) * 0.6);
  slab.castShadow = true; slab.receiveShadow = true;
  building.add(slab);

  // facade glass shell slightly inset
  const shellGeom = new THREE.BoxGeometry(w * 0.92, h * 0.9, d * 0.92);
  const shell = new THREE.Mesh(shellGeom, glassThin);
  shell.position.set(slab.position.x, y + h / 2 + 0.06, slab.position.z);
  shell.castShadow = true; shell.receiveShadow = false;
  building.add(shell);

  // mullions: vertical thin frames
  const mullions = new THREE.Group();
  const cols = Math.max(5, Math.floor(w / 3));
  for (let c = 0; c <= cols; c++) {
    const mx = - (w * 0.92) / 2 + (c / cols) * (w * 0.92);
    const mGeo = new THREE.BoxGeometry(0.14, h * 0.9, 0.18);
    const mMesh = new THREE.Mesh(mGeo, aluminum);
    mMesh.position.set(shell.position.x + mx, shell.position.y, shell.position.z + (d * 0.92 / 2) - 0.09);
    mullions.add(mMesh);
    const mMesh2 = mMesh.clone(); mMesh2.position.z = shell.position.z - (d * 0.92 / 2) + 0.09; mullions.add(mMesh2);
  }
  building.add(mullions);

  // balconies with glass rail
  if (i % 3 === 2) {
    const balWidth = Math.min(8, w * 0.28);
    const bal = new THREE.Mesh(new THREE.BoxGeometry(balWidth, 0.18, d * 0.32), stone);
    bal.position.set(slab.position.x + w * 0.38, y + 0.18, slab.position.z + d * 0.18);
    building.add(bal);
    const rail = new THREE.Mesh(new THREE.BoxGeometry(balWidth * 0.98, 1.0, 0.06), glassThin);
    rail.position.set(bal.position.x, bal.position.y + 0.6, bal.position.z + 0.0);
    building.add(rail);
  }

  // small green planters
  if ((i % 6 === 1) || (i % 7 === 4)) {
    const plan = new THREE.Mesh(new THREE.BoxGeometry(w * 0.2, 0.36, d * 0.18), planterMat);
    plan.position.set(slab.position.x - w * 0.35, y + 0.18, slab.position.z - d * 0.22);
    building.add(plan);
  }

  y += h;
}

// roof lantern
const lanternOuter = new THREE.Mesh(new THREE.CylinderGeometry(6.8, 10.2, 10, 24, 1, true), glassThin);
lanternOuter.position.set(0, y + 6, 0); lanternOuter.castShadow = true; building.add(lanternOuter);
const lanternInner = new THREE.Mesh(new THREE.CylinderGeometry(3.2, 6.2, 6, 16), aluminum);
lanternInner.position.set(0, y + 6, 0); building.add(lanternInner);

// rooftop garden block
const roofGarden = new THREE.Mesh(new THREE.BoxGeometry(params.baseW * 0.52, 1.2, params.baseD * 0.42), planterMat);
roofGarden.position.set(0, y + 2.6, 0);
building.add(roofGarden);

// subtle tilt for composition
building.rotation.y = THREE.MathUtils.degToRad(params.rotationOffset);

// update contact shadow scale to match building footprint
contactMesh.scale.set(1,1,1);

}

buildHighDetail();

// --- Decorative: fountain and benches --- const fountain = new THREE.Mesh(new THREE.CylinderGeometry(6,6,0.8,48), new THREE.MeshStandardMaterial({ color:0xdff6ff, roughness:0.25 })); fountain.position.set(-36, 0.4, 18); fountain.castShadow = true; scene.add(fountain);

function makeLamp(x,z){ const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,4,8), aluminum); pole.position.set(x,2,z); const head = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.2,0.4), new THREE.MeshStandardMaterial({ emissive:0xfff1d0, emissiveIntensity:0.8 })); head.position.set(x,4.2,z); scene.add(pole); scene.add(head); } makeLamp(62,-230); makeLamp(-62,-230); makeLamp(132,-240);

// --- UI overlay for export and param control --- const ui = document.createElement('div'); ui.style.position='absolute'; ui.style.top='12px'; ui.style.left='12px'; ui.style.zIndex=1000; ui.style.background='rgba(10,12,16,0.45)'; ui.style.padding='10px'; ui.style.borderRadius='8px'; ui.style.color='#fff'; ui.style.fontFamily='system-ui,Arial'; ui.innerHTML = <div style="font-weight:700;margin-bottom:6px">Scribe Haus â€” Client Model</div> Floors: <input id='f' type='number' min='6' max='80' value='${params.floors}' style='width:72px' /> <button id='re' style='margin-left:8px;padding:6px;background:#0b84ff;border:none;border-radius:6px;color:#fff;cursor:pointer'>Rebuild</button> <div style='margin-top:8px'> <button id='gltf' style='padding:6px 10px;background:#047857;border:none;border-radius:6px;color:#fff;cursor:pointer'>Download .gltf</button> <button id='glb' style='padding:6px 10px;margin-left:6px;background:#0ea5a4;border:none;border-radius:6px;color:#fff;cursor:pointer'>Download .glb</button> </div>; container.appendChild(ui);

ui.querySelector('#re').addEventListener('click', ()=>{ const v = parseInt(ui.querySelector('#f').value) || params.floors; params.floors = Math.max(6, Math.min(120, v)); buildHighDetail(); });

const exporter = new GLTFExporter();

function saveBlob(buffer, filename) { const blob = new Blob([buffer], { type: 'application/octet-stream' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = filename; link.click(); setTimeout(()=>URL.revokeObjectURL(link.href),1500); } function saveString(text, filename) { const blob = new Blob([text], { type: 'application/json' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = filename; link.click(); setTimeout(()=>URL.revokeObjectURL(link.href),1500); }

ui.querySelector('#gltf').addEventListener('click', ()=>{ exporter.parse(root, function(result){ const output = JSON.stringify(result, null, 2); saveString(output, scribehaus_skyscraper_${params.floors}f.gltf); }, { binary: false, embedImages: true }); }); ui.querySelector('#glb').addEventListener('click', ()=>{ exporter.parse(root, function(result){ saveBlob(result, scribehaus_skyscraper_${params.floors}f.glb); }, { binary: true }); });

// --- Render loop --- function animate(){ requestAnimationFrame(animate); building.rotation.y += 0.0009; controls.update(); renderer.render(scene, camera); } animate();

// responsiveness window.addEventListener('resize', ()=>{ camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth, container.clientHeight); });

// --- Utilities --- function generateRadialShadowCanvas(size){ const c = document.createElement('canvas'); c.width = c.height = size; const ctx = c.getContext('2d'); const g = ctx.createRadialGradient(size/2, size/2, size*0.08, size/2, size/2, size/2); g.addColorStop(0, 'rgba(0,0,0,0.9)'); g.addColorStop(0.22, 'rgba(0,0,0,0.55)'); g.addColorStop(0.45, 'rgba(0,0,0,0.25)'); g.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = g; ctx.fillRect(0,0,size,size); return c; } }

